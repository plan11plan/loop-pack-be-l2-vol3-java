
---

## 0. 요구사항 분석 과정에서 던진 질문들

요구사항을 명확히 하기 위해 개발자(나)가 던진 질문과 결정 내용을 정리합니다.

### 장바구니 (Cart)

| # | 질문 | 결정 |
|---|------|------|
| 1 | 장바구니 상품의 유효성 체크를 언제 할 것인가? (조회 시 실시간 vs 이벤트로 즉시 정리) | **조회 시 실시간 체크** — 장바구니 테이블은 단순 유지, 조회 시 상품/브랜드 상태를 확인하여 필터링 |
| 2 | 장바구니 담기 시 재고를 확인하는가? | **담을 때는 확인 안 함** — 주문 시점에만 확인. 장바구니는 "보관함" 성격 |
| 3 | 장바구니 수량 상한을 두는가? | **최대 100종류, 상품당 최대 99개** — 페이지네이션 적용 |
| 4 | 장바구니에 수량 '변경' 기능이 필요한가? (담기/제거만 vs 수량 직접 변경) | **수량 직접 변경 API 추가** — PUT /api/v1/carts/{cartItemId}로 원하는 수량 직접 지정 |
| 5 | 장바구니에 표시할 가격은 어떤 시점 기준인가? | **항상 현재 가격** — 장바구니에 가격 저장 안 함. 주문 시점에 스냅샷으로 확정 |
| 6 | 수량 변경 API에서 수량 0으로 변경하면 삭제 처리할 것인가? | **수량 0은 불가, 최소 1** — 제거는 DELETE API로만 가능. 역할 명확히 분리 |
| 7 | 장바구니 담기 시 quantity 기본값은? | **필수값 (기본값 없음)** — 클라이언트가 명시적으로 전달 |
| 8 | 장바구니에서 바로 주문으로 전환하는 기능이 필요한가? | **클라이언트 레벨 전환** — Cart→Order 서버 의존성 없이, 클라이언트가 장바구니 조회 후 기존 주문 API에 직접 요청 |

### 브랜드 관심/좋아요

| # | 질문 | 결정 |
|---|------|------|
| 9 | 브랜드 좋아요(관심) 기능을 추가할 것인가? | **제외** — 처음엔 추가하려 했으나, 분석 과정에서 현 단계에서는 불필요하다고 판단하여 제외 |

### 삭제 전략

| # | 질문 | 결정 |
|---|------|------|
| 10 | 브랜드/상품 삭제 방식은? (Hard Delete vs Soft Delete) | **Soft Delete** — deleted_at 컬럼. 복구 가능성, 조회 시 필터링 방식과 일관성 |
| 11 | 브랜드 삭제 시 연관 데이터(장바구니, 좋아요) 처리는? | **조회 시 필터링** — 브랜드 soft delete → 상품 soft delete → 장바구니/좋아요는 조회 시 필터링. 트랜잭션 비대화 방지 |

### 좋아요 (ProductLike)

| # | 질문 | 결정 |
|---|------|------|
| 12 | 좋아요 수(카운트)를 어떻게 관리할 것인가? | **조회 시 COUNT 쿼리** — 별도 likeCount 컬럼 없이, likes 테이블 COUNT로 산출. 정합성 100% |
| 13 | 좋아요 API를 토글 방식으로 할 것인가, POST/DELETE 분리로 할 것인가? | **엔드포인트 분리 + 내부 토글** — POST/DELETE 엔드포인트는 미션 스펙 유지, 내부적으로는 같은 toggleLike 호출 |
| 14 | 이미 좋아요한 상품에 다시 POST 요청 시 어떻게 처리할 것인가? (멱등성) | **토글 처리** — 이미 좋아요 상태면 취소, 좋아요하지 않은 상태면 등록. 409/404 없음 |

### 상품 (Product)

| # | 질문 | 결정 |
|---|------|------|
| 15 | 상품 재고(stock)를 어떻게 관리할 것인가? | **Product에 stock 필드 포함** — 별도 Stock 도메인 분리 없이 단순하게 관리 |

### 문서 작성

| # | 질문 | 결정 |
|---|------|------|
| 16 | 설계 문서 저장 위치는? (.claude/ vs docs/design/) | **docs/design/** — 과제 제출 요구사항 기준 |
| 17 | 유비쿼터스 언어(도메인 용어집)를 포함할 것인가? | **포함** — 리뷰어에게 좋은 인상 + 도메인 소통 기준 |
| 18 | 설계 결정 근거를 포함할 것인가? | **포함** — "왜 이렇게 판단했는가"가 드러나는 문서 |

---
---

## 1. 도메인 용어집 (Ubiquitous Language)

| 한글 | 영문 | 설명 |
|------|------|------|
| 회원 | User (Member) | 서비스에 가입한 사용자. 1주차에 구현 완료 (본 설계 범위 제외) |
| 브랜드 | Brand | 상품을 판매하는 브랜드. Admin이 등록/관리 |
| 상품 | Product | 브랜드에 속한 판매 상품. 재고(stock) 포함 |
| 재고 | stock | 상품의 현재 판매 가능 수량. Product의 필드로 관리 |
| 품절 | Sold Out | 상품 재고(stock)가 0인 상태 |
| 좋아요 | ProductLike | 회원이 상품에 대해 표현하는 선호. 회원당 상품당 1개. 별도 테이블로 관리 |
| 장바구니 | Cart | 회원이 구매 전 상품을 담아두는 보관함 |
| 장바구니 항목 | CartItem | 장바구니에 담긴 개별 상품과 수량 |
| 주문 | Order | 회원이 상품을 구매하기 위한 요청 |
| 주문 항목 | OrderItem | 주문에 포함된 개별 상품의 스냅샷 (주문 시점 가격/이름 등) |
| 스냅샷 | Snapshot | 주문 시점의 상품 정보를 복사하여 저장하는 것 |
| Soft Delete | - | deleted_at 컬럼으로 논리 삭제. 물리적으로는 데이터 유지 |
| Admin | Admin | LDAP 인증 기반 사내 관리자 |

---

## 2. 설계 범위

### 포함 도메인
- 브랜드 (Brand)
- 상품 (Product)
- 좋아요 (ProductLike)
- 장바구니 (Cart) -- **추가 기능**
- 주문 (Order)

### 제외 도메인
- 회원 (User): 1주차에 구현 완료
- 결제 (Payment): 추후 개발 예정
- 쿠폰 (Coupon): 추후 개발 예정

---

## 3. 액터 및 API 식별 규칙

### 액터

| 액터 | 설명 | 식별 방식 |
|------|------|----------|
| 비회원 (Guest) | 로그인하지 않은 사용자 | 헤더 없음 |
| 회원 (User) | 로그인한 사용자 | `X-Loopers-LoginId`, `X-Loopers-LoginPw` |
| 관리자 (Admin) | 사내 관리자 | `X-Loopers-Ldap: loopers.admin` |

### API Prefix 규칙
- 대고객 API: `/api/v1`
- 어드민 API: `/api-admin/v1`

### 인증/인가
- 인증/인가 로직은 구현하지 않음 (주요 스코프 아님)
- 헤더 기반으로 사용자를 식별만 함
- 회원은 타 회원의 정보에 직접 접근할 수 없음

---

## 4. 도메인별 요구사항

---

### 4.1 브랜드 (Brand)

#### 유저 스토리

> **비회원으로서**, 브랜드 정보를 조회할 수 있다. 로그인 없이도 브랜드를 탐색하고 싶다.
>
> **관리자로서**, 브랜드를 등록/수정/삭제하여 서비스에 입점할 브랜드를 관리할 수 있다.

#### 기능 목록

| 기능 | 액터 | Method | URI | 인증 |
|------|------|--------|-----|------|
| 브랜드 정보 조회 | 비회원/회원 | GET | `/api/v1/brands/{brandId}` | X |
| 브랜드 목록 조회 | Admin | GET | `/api-admin/v1/brands?page=0&size=20` | LDAP |
| 브랜드 상세 조회 | Admin | GET | `/api-admin/v1/brands/{brandId}` | LDAP |
| 브랜드 등록 | Admin | POST | `/api-admin/v1/brands` | LDAP |
| 브랜드 정보 수정 | Admin | PUT | `/api-admin/v1/brands/{brandId}` | LDAP |
| 브랜드 삭제 | Admin | DELETE | `/api-admin/v1/brands/{brandId}` | LDAP |

> **고객 vs Admin 응답 차이**: 고객에게는 브랜드명, 설명 등 기본 정보만 제공.
> Admin에게는 등록일, 수정일, 삭제 여부, 소속 상품 수 등 관리 정보도 추가로 제공.

#### 유스케이스 흐름

**UC-B01: 브랜드 정보 조회 (비회원)**

```
[유저 스토리]
- 비회원이 특정 브랜드의 정보를 확인할 수 있다.

[기능 흐름]
1. 비회원이 brandId로 브랜드 정보를 요청한다
2. 해당 브랜드가 존재하는지 확인한다
3. 브랜드 기본 정보를 반환한다

[예외]
- brandId에 해당하는 브랜드가 없으면 404 반환
- soft delete된 브랜드는 조회 불가 (404 반환)
```

**UC-B02: 브랜드 등록 (Admin)**

```
[유저 스토리]
- Admin이 새로운 브랜드를 서비스에 등록할 수 있다.

[기능 흐름]
1. Admin이 브랜드 정보(이름 등)를 입력한다
2. 동일한 브랜드명이 이미 존재하는지 확인한다
3. 브랜드를 저장한다
4. 생성된 브랜드 정보를 반환한다

[예외]
- 이미 존재하는 브랜드명이면 등록 실패 (409 Conflict)

[조건]
- 브랜드명은 필수값이며 중복 불가
```

**UC-B03: 브랜드 정보 수정 (Admin)**

```
[유저 스토리]
- Admin이 브랜드의 정보를 수정할 수 있다.

[기능 흐름]
1. Admin이 brandId와 수정할 정보를 요청한다
2. 해당 브랜드가 존재하는지 확인한다
3. 브랜드 정보를 업데이트한다

[예외]
- brandId에 해당하는 브랜드가 없거나 삭제된 경우 404 반환
- 수정하려는 브랜드명이 다른 브랜드와 중복되면 409 Conflict
```

**UC-B04: 브랜드 삭제 (Admin)**

```
[유저 스토리]
- Admin이 브랜드를 삭제하면, 해당 브랜드의 상품들도 함께 삭제된다.

[기능 흐름]
1. Admin이 brandId로 삭제를 요청한다
2. 해당 브랜드가 존재하는지 확인한다
3. 해당 브랜드를 soft delete 한다
4. 해당 브랜드의 모든 상품도 soft delete 한다

[예외]
- brandId에 해당하는 브랜드가 없으면 404 반환
- 이미 삭제된 브랜드이면 404 반환

[후속 동작]
- 장바구니/좋아요는 즉시 삭제하지 않음
- 조회 시점에 상품/브랜드의 deleted_at을 체크하여 필터링
```

> **연쇄 처리 범위**:
> ```
> 브랜드 soft delete
>   └→ 해당 브랜드의 상품 전체 soft delete
>       └→ 장바구니 항목: 조회 시 필터링
>       └→ 좋아요: 조회 시 필터링
> ```

---

### 4.2 상품 (Product)

#### 유저 스토리

> **비회원으로서**, 상품 목록을 둘러보고 상세 정보를 확인할 수 있다.
>
> **관리자로서**, 상품을 등록/수정/삭제하여 판매 상품을 관리할 수 있다.
> 상품 등록 시 재고(stock)를 설정하고, 수정 시 재고를 변경할 수 있다.

#### 기능 목록

| 기능 | 액터 | Method | URI | 인증 |
|------|------|--------|-----|------|
| 상품 목록 조회 | 비회원/회원 | GET | `/api/v1/products` | X |
| 상품 정보 조회 | 비회원/회원 | GET | `/api/v1/products/{productId}` | X |
| 상품 목록 조회 | Admin | GET | `/api-admin/v1/products?page=0&size=20&brandId={brandId}` | LDAP |
| 상품 상세 조회 | Admin | GET | `/api-admin/v1/products/{productId}` | LDAP |
| 상품 등록 | Admin | POST | `/api-admin/v1/products` | LDAP |
| 상품 정보 수정 | Admin | PUT | `/api-admin/v1/products/{productId}` | LDAP |
| 상품 삭제 | Admin | DELETE | `/api-admin/v1/products/{productId}` | LDAP |

#### 상품 목록 조회 쿼리 파라미터

| 파라미터 | 설명 | 기본값 |
|----------|------|--------|
| `brandId` | 특정 브랜드 상품 필터링 | - (선택) |
| `sort` | 정렬 기준: `latest` / `price_asc` / `likes_desc` | `latest` |
| `page` | 페이지 번호 | 0 |
| `size` | 페이지당 상품 수 | 20 |

> `sort`는 `latest` 필수, `price_asc` / `likes_desc`는 선택 구현.
> `likes_desc` 정렬 시 좋아요 수는 likes 테이블 COUNT로 산출.

#### 유스케이스 흐름

**UC-P01: 상품 목록 조회 (비회원)**

```
[유저 스토리]
- 비회원이 상품 목록을 둘러볼 수 있다.
- 브랜드별 필터링, 정렬, 페이지네이션을 지원한다.

[기능 흐름]
1. 비회원이 상품 목록을 요청한다 (선택: brandId, sort, page, size)
2. soft delete된 상품/브랜드를 제외한다
3. 정렬 조건에 맞게 정렬한다
4. 페이지네이션하여 상품 목록을 반환한다
5. 각 상품의 좋아요 수를 likes 테이블 COUNT로 함께 반환한다

[대안 흐름]
- brandId가 없으면 전체 상품 조회
- sort가 없으면 latest(최신순) 기본 적용

[조건]
- soft delete된 상품은 목록에서 제외
- soft delete된 브랜드의 상품도 목록에서 제외
```

**UC-P02: 상품 정보 조회 (비회원)**

```
[유저 스토리]
- 비회원이 특정 상품의 상세 정보를 확인할 수 있다.

[기능 흐름]
1. 비회원이 productId로 상품 정보를 요청한다
2. 해당 상품이 존재하는지 확인한다
3. 상품 정보와 함께 좋아요 수(COUNT)를 반환한다

[예외]
- productId에 해당하는 상품이 없거나 삭제된 경우 404 반환

[조건]
- 좋아요 수는 likes 테이블에서 해당 상품의 COUNT 쿼리로 산출
```

**UC-P03: 상품 등록 (Admin)**

```
[유저 스토리]
- Admin이 특정 브랜드에 새 상품을 등록할 수 있다.

[기능 흐름]
1. Admin이 상품 정보를 입력한다 (brandId, 상품명, 가격, 재고 등)
2. brandId에 해당하는 브랜드가 존재하는지 확인한다
3. 상품을 저장한다
4. 생성된 상품 정보를 반환한다

[예외]
- brandId에 해당하는 브랜드가 없거나 삭제된 경우 등록 실패

[조건]
- 상품의 브랜드는 반드시 이미 등록된(삭제되지 않은) 브랜드여야 함
- 재고(stock)는 상품 등록 시 초기값 설정 (0 이상)
```

**UC-P04: 상품 정보 수정 (Admin)**

```
[유저 스토리]
- Admin이 상품의 정보(이름, 가격, 재고 등)를 수정할 수 있다.
- 단, 상품이 속한 브랜드는 변경할 수 없다.

[기능 흐름]
1. Admin이 productId와 수정할 정보를 요청한다
2. 해당 상품이 존재하는지 확인한다
3. 상품 정보를 업데이트한다

[예외]
- productId에 해당하는 상품이 없거나 삭제된 경우 404 반환

[조건]
- 상품의 브랜드(brandId)는 수정할 수 없음
- 재고(stock) 수정 가능
```

**UC-P05: 상품 삭제 (Admin)**

```
[유저 스토리]
- Admin이 상품을 삭제할 수 있다.

[기능 흐름]
1. Admin이 productId로 삭제를 요청한다
2. 해당 상품이 존재하는지 확인한다
3. 해당 상품을 soft delete 한다

[예외]
- productId에 해당하는 상품이 없거나 이미 삭제된 경우 404 반환

[후속 동작]
- 장바구니/좋아요는 즉시 삭제하지 않음
- 조회 시점에 필터링으로 처리
```

---

### 4.3 좋아요 (ProductLike)

#### 유저 스토리

> **회원으로서**, 마음에 드는 상품에 좋아요를 눌러 선호를 표현하고, 나중에 다시 찾아볼 수 있다.
> 이미 좋아요한 상품은 취소할 수 있다.

#### 기능 목록

| 기능 | 액터 | Method | URI | 인증 |
|------|------|--------|-----|------|
| 상품 좋아요 등록 | 회원 | POST | `/api/v1/products/{productId}/likes` | O |
| 상품 좋아요 취소 | 회원 | DELETE | `/api/v1/products/{productId}/likes` | O |
| 내가 좋아요한 상품 목록 조회 | 회원 | GET | `/api/v1/users/{userId}/likes` | O |

> **좋아요 수 관리**: 별도 likeCount 컬럼 없이, 조회 시 likes 테이블 COUNT 쿼리로 산출.
> 상품 조회/목록 응답에 좋아요 수가 포함됨.
>
> **토글 방식**: POST/DELETE 엔드포인트는 분리하되, 내부적으로 같은 토글 로직(toggleLike)을 호출합니다.

#### 유스케이스 흐름

**UC-L01: 상품 좋아요 토글 (등록/취소)**

```
[유저 스토리]
- 회원이 마음에 드는 상품에 좋아요를 누르면 등록되고, 다시 요청하면 취소된다.

[기능 흐름]
1. 회원이 productId로 좋아요를 요청한다 (POST 또는 DELETE)
2. 해당 상품이 존재하는지 확인한다 (삭제된 상품 불가)
3. 좋아요 존재 여부를 확인한다
4-a. 좋아요가 없으면: 좋아요를 저장한다 (등록)
4-b. 좋아요가 있으면: 좋아요를 삭제한다 (취소)

[예외]
- productId에 해당하는 상품이 없거나 삭제된 경우 404 반환

[조건]
- 로그인한 회원만 가능
- 회원당 상품당 1개만 저장 (유니크 제약)
- POST/DELETE 모두 같은 Facade 메서드(toggleLike)를 호출
- 이미 좋아요한 상품에 POST → 좋아요 취소 (409 없음)
- 좋아요하지 않은 상품에 DELETE → 좋아요 등록 (404 없음)
```

**UC-L02: 내가 좋아요한 상품 목록 조회**

```
[유저 스토리]
- 회원이 자신이 좋아요 누른 상품 목록을 확인할 수 있다.

[기능 흐름]
1. 회원이 자신의 좋아요 목록을 요청한다
2. likes 테이블에서 해당 회원의 좋아요 목록을 조회한다
3. 상품/브랜드가 삭제되지 않은 항목만 필터링한다
4. 상품 정보와 함께 반환한다

[조건]
- 로그인한 회원만 가능
- soft delete된 상품/브랜드는 목록에서 제외 (조회 시 필터링)
- 본인의 좋아요 목록만 조회 가능 (타 유저 접근 불가)
```

---

### 4.4 장바구니 (Cart) -- 추가 기능

#### 유저 스토리

> **회원으로서**, 구매하고 싶은 상품을 장바구니에 담아두고 나중에 한 번에 확인할 수 있다.
> 담은 상품의 수량을 변경하거나 제거할 수 있다.
> 장바구니에 품절 상품이 있으면 품절 상태로 보여주고, 삭제된 상품/브랜드는 자동으로 걸러진다.

#### 기능 목록

| 기능 | 액터 | Method | URI | 인증 |
|------|------|--------|-----|------|
| 장바구니에 상품 담기 | 회원 | POST | `/api/v1/carts` | O |
| 장바구니 목록 조회 | 회원 | GET | `/api/v1/carts?page=0&size=20` | O |
| 장바구니 수량 변경 | 회원 | PUT | `/api/v1/carts/{cartItemId}` | O |
| 장바구니 항목 제거 | 회원 | DELETE | `/api/v1/carts/{cartItemId}` | O |

#### 유스케이스 흐름

**UC-C01: 장바구니에 상품 담기**

```
[유저 스토리]
- 회원이 상품을 장바구니에 담을 수 있다.
- 같은 상품을 다시 담으면 수량이 합산된다.

[기능 흐름]
1. 회원이 productId와 quantity(필수)로 담기를 요청한다
2. 해당 상품이 존재하는지 확인한다 (삭제된 상품 불가)
3. 장바구니에 같은 상품이 이미 있는지 확인한다
4-a. 없으면: 새 CartItem을 저장한다
4-b. 있으면: 기존 수량에 요청 수량을 합산한다

[예외]
- productId에 해당하는 상품이 없거나 삭제된 경우 실패
- 합산 후 수량이 99를 초과하면 실패
- 장바구니에 이미 100종류가 담겨있으면 신규 상품 담기 실패

[조건]
- quantity는 필수값 (기본값 없음), 1 이상
- 담을 때 재고는 확인하지 않음 (주문 시점에 확인)
- 가격은 저장하지 않음 (조회 시 현재 가격 사용)
- 로그인한 회원만 가능
```

**UC-C02: 장바구니 목록 조회**

```
[유저 스토리]
- 회원이 자신의 장바구니를 확인할 수 있다.
- 품절 상품은 품절로 표시되고, 삭제된 상품은 자동으로 걸러진다.

[기능 흐름]
1. 회원이 장바구니 목록을 요청한다 (page, size)
2. 해당 회원의 장바구니 항목을 조회한다
3. 각 항목의 상품/브랜드가 삭제되었는지 확인한다
4. 삭제된 상품/브랜드의 항목은 목록에서 제외한다
5. 품절(stock=0) 상품은 품절 상태를 표시한다
6. 상품의 현재 정보(이름, 가격, 재고 상태)와 함께 반환한다

[조건]
- 가격은 항상 현재 상품 가격 기준 (장바구니에 가격 저장 안 함)
- 페이지네이션 적용 (장바구니 최대 100종류)
- 본인의 장바구니만 조회 가능
- 로그인한 회원만 가능
```

**UC-C03: 장바구니 수량 변경**

```
[유저 스토리]
- 회원이 장바구니에 담긴 상품의 수량을 변경할 수 있다.

[기능 흐름]
1. 회원이 cartItemId와 변경할 quantity를 요청한다
2. 해당 장바구니 항목이 존재하는지 확인한다
3. 본인의 장바구니 항목인지 확인한다
4. 수량을 업데이트한다

[예외]
- cartItemId에 해당하는 항목이 없으면 404 반환
- 수량이 1 미만이면 실패 (최소 1)
- 수량이 99 초과이면 실패 (최대 99)

[조건]
- 수량 0으로 변경 불가 → 제거는 DELETE API로만 가능
- 본인의 장바구니 항목만 수정 가능
- 로그인한 회원만 가능
```

**UC-C04: 장바구니 항목 제거**

```
[유저 스토리]
- 회원이 장바구니에서 상품을 제거할 수 있다.

[기능 흐름]
1. 회원이 cartItemId로 제거를 요청한다
2. 해당 장바구니 항목이 존재하는지 확인한다
3. 본인의 장바구니 항목인지 확인한다
4. 해당 항목을 삭제한다

[예외]
- cartItemId에 해당하는 항목이 없으면 404 반환

[조건]
- 본인의 장바구니 항목만 제거 가능
- 로그인한 회원만 가능
```

#### 장바구니 → 주문 관계

장바구니와 주문은 **서버 도메인 간 독립적**이다.

```
[클라이언트 레벨 전환 흐름]
1. 클라이언트가 GET /api/v1/carts 로 장바구니 조회
2. 사용자가 주문할 상품을 선택
3. 클라이언트가 POST /api/v1/orders 에 items를 직접 조립하여 요청
4. 주문 성공 후 클라이언트가 DELETE /api/v1/carts/{cartItemId} 로 정리
```

- 서버에서 Cart 도메인과 Order 도메인은 서로 참조하지 않음
- 별도의 "장바구니에서 주문" API 없음

---

### 4.5 주문 (Order)

#### 유저 스토리

> **회원으로서**, 여러 상품을 한 번에 주문할 수 있다.
> 주문 시 상품 재고가 확인되고 차감된다.
> 주문 후에도 당시 상품 정보(가격, 이름 등)를 확인할 수 있다.
>
> **관리자로서**, 전체 주문 내역을 조회할 수 있다.

#### 기능 목록

| 기능 | 액터 | Method | URI | 인증 |
|------|------|--------|-----|------|
| 주문 요청 | 회원 | POST | `/api/v1/orders` | O |
| 주문 목록 조회 | 회원 | GET | `/api/v1/orders?startAt={date}&endAt={date}` | O |
| 주문 상세 조회 | 회원 | GET | `/api/v1/orders/{orderId}` | O |
| 주문 목록 조회 | Admin | GET | `/api-admin/v1/orders?page=0&size=20` | LDAP |
| 주문 상세 조회 | Admin | GET | `/api-admin/v1/orders/{orderId}` | LDAP |

#### 주문 요청 본문 예시

```json
{
  "items": [
    { "productId": 1, "quantity": 2 },
    { "productId": 3, "quantity": 1 }
  ]
}
```

#### 유스케이스 흐름

**UC-O01: 주문 요청**

```
[유저 스토리]
- 회원이 여러 상품을 한 번에 주문할 수 있다.
- 주문 시 재고가 확인되고 차감된다.
- 주문 정보에는 당시 상품 정보가 스냅샷으로 저장된다.

[기능 흐름]
1. 회원이 상품 목록(productId, quantity)으로 주문을 요청한다
2. 각 상품이 존재하는지 확인한다 (삭제된 상품 불가)
3. 각 상품의 재고가 충분한지 확인한다
4. 재고를 차감한다 (원자적 처리)
5. 주문 시점의 상품 정보를 스냅샷으로 저장한다 (상품명, 가격, 브랜드명 등)
6. 주문을 생성한다

[예외]
- 상품이 존재하지 않거나 삭제된 경우 주문 실패
- 재고가 부족한 상품이 하나라도 있으면 주문 전체 실패
- items가 비어있으면 주문 실패

[조건]
- 로그인한 회원만 가능
- 재고 확인과 차감은 원자적으로 처리되어야 함
- 동시성 이슈는 추후 해결 (비관적 락 또는 낙관적 락)
```

> **스냅샷의 이유**: 주문 이후 상품 가격이 변경되거나 상품/브랜드가 삭제되어도,
> 주문 내역에는 주문 당시 정보가 그대로 남아야 한다.

**UC-O02: 주문 목록 조회 (회원)**

```
[유저 스토리]
- 회원이 특정 기간의 자신의 주문 내역을 확인할 수 있다.

[기능 흐름]
1. 회원이 기간(startAt, endAt)을 지정하여 주문 목록을 요청한다
2. 해당 기간 내 본인의 주문 목록을 반환한다

[조건]
- 본인의 주문만 조회 가능
- startAt, endAt은 필수값 (기간 지정 필수)
```

**UC-O03: 주문 상세 조회 (회원)**

```
[유저 스토리]
- 회원이 특정 주문의 상세 내역을 확인할 수 있다.
- 주문 당시의 상품 정보(스냅샷)가 표시된다.

[기능 흐름]
1. 회원이 orderId로 주문 상세를 요청한다
2. 해당 주문이 존재하는지 확인한다
3. 본인의 주문인지 확인한다
4. 주문 정보와 스냅샷된 상품 정보를 반환한다

[예외]
- orderId에 해당하는 주문이 없으면 404 반환
- 본인의 주문이 아니면 접근 불가

[조건]
- 본인의 주문만 조회 가능
- 상품 정보는 스냅샷 기준 (현재 상품 상태와 무관)
```

---

## 5. 설계 결정 사항

이 프로젝트에서 내린 주요 설계 결정과 그 근거를 정리합니다.

### 5.1 삭제 전략: Soft Delete

**결정**: 브랜드/상품 삭제 시 `deleted_at` 컬럼을 사용한 논리 삭제

**근거**:
- 주문에 스냅샷이 남지만, 관리자가 삭제된 브랜드/상품 이력을 확인할 필요가 있을 수 있음
- 실수로 삭제한 경우 복구 가능성을 열어둠
- 장바구니/좋아요 등 연관 데이터를 즉시 삭제하지 않고 **조회 시 필터링**으로 처리하여 트랜잭션 범위를 줄임

**트레이드오프**:
- 모든 조회 쿼리에 `deleted_at IS NULL` 조건이 추가됨
- 데이터가 물리적으로 남아있어 스토리지를 차지함

### 5.2 브랜드 삭제 연쇄 처리: 조회 시 필터링

**결정**: 브랜드 삭제 시 상품은 함께 soft delete 하되, 장바구니/좋아요는 **조회 시점에 필터링**

**근거**:
- 브랜드 삭제 트랜잭션이 비대해지는 것을 방지
- 장바구니/좋아요까지 한 트랜잭션에서 삭제하면 도메인 간 결합도가 높아짐
- Soft Delete + 조회 시 필터링 방식이 일관된 접근

### 5.3 좋아요 수 관리: 조회 시 COUNT 쿼리

**결정**: Product에 별도 likeCount 컬럼을 두지 않고, 조회 시 likes 테이블 COUNT 쿼리로 산출

**근거**:
- 데이터 정합성 100% (카운트 불일치 문제 없음)
- 구현 단순 (등록/취소 시 카운트 업데이트 로직 불필요)
- 동시성 이슈 없음

**트레이드오프**:
- 상품 목록 조회 시 JOIN + COUNT 쿼리 비용 발생
- 대량 데이터 시 성능 이슈 가능 → 필요 시 likeCount 캐싱 컬럼 도입 고려

### 5.4 좋아요 API: 엔드포인트 분리 + 내부 토글

**결정**: POST/DELETE 엔드포인트는 미션 스펙대로 분리하되, 내부적으로 같은 Facade 메서드(toggleLike)를 호출

**근거**:
- 미션 요구사항 API 스펙 준수 (POST/DELETE 엔드포인트 유지)
- 내부 로직 단순화 (등록/취소 분기 없이 토글 1개 메서드)
- 상품 검증은 항상 수행 (삭제된 상품에 대한 좋아요 조작 방지)

**토글 동작**:
- 좋아요가 없는 상태에서 요청 → 좋아요 등록
- 좋아요가 있는 상태에서 요청 → 좋아요 취소
- 409 Conflict, 404 Not Found(좋아요 미등록) 없음

### 5.5 장바구니 가격: 현재 가격 기준

**결정**: 장바구니에 가격을 저장하지 않고, 조회 시 항상 현재 상품 가격을 사용

**근거**:
- 장바구니는 "보관함" 성격. 가격이 확정되는 시점은 주문 시점
- 장바구니에 가격을 저장하면 가격 변동 시 동기화 문제 발생
- 주문에서 스냅샷으로 가격이 확정되므로, 장바구니까지 가격을 관리할 필요 없음

### 5.6 장바구니 담기 시 재고 미확인

**결정**: 장바구니에 담을 때는 재고를 확인하지 않고, 주문 시점에만 확인

**근거**:
- 장바구니는 "위시리스트"에 가까운 성격
- 담을 때 재고를 확인해도, 주문 시점까지 재고가 변동될 수 있어 의미가 제한적
- 구현 복잡도를 낮추면서 주문 시점 검증으로 데이터 정합성 보장

### 5.7 장바구니와 주문: 서버 도메인 간 독립

**결정**: 장바구니에서 주문으로의 전환은 클라이언트 레벨에서 처리. 서버에서 Cart와 Order 도메인은 서로 참조하지 않음

**근거**:
- 도메인 간 결합도를 0으로 유지
- 별도의 전환 API 없이 기존 주문 API 재사용
- 장바구니 기능이 변경되어도 주문에 영향 없음, 반대도 마찬가지

### 5.8 장바구니 제약 조건

| 제약 | 값 | 근거 |
|------|-----|------|
| 상품당 최대 수량 | 99개 | 비정상 요청 방어 |
| 장바구니 최대 종류 | 100종 | 합리적 상한 + 페이지네이션 적용 |
| 최소 수량 | 1개 | 수량 0은 불가. 제거는 DELETE API로 명확히 분리 |
| quantity | 필수값 | 기본값 없음. 클라이언트가 명시적으로 전달 |

### 5.9 상품 재고: Product 필드로 관리

**결정**: 재고(stock)를 Product 엔티티의 필드로 관리. 별도 Stock 도메인 분리 없음.

**근거**:
- 현재 요구사항에서 입고/출고 이력 관리가 필요하지 않음
- 상품 등록/수정 시 재고 설정, 주문 시 차감만 하면 충분
- 별도 도메인 분리는 오버 엔지니어링

---

## 6. 잠재 리스크

| 리스크 | 설명 | 대응 방안 |
|--------|------|----------|
| 조회 시 필터링 비용 | Soft Delete + 조회 필터링으로 장바구니/좋아요 조회 시 JOIN과 조건이 증가 | 인덱스 전략으로 대응. 필요시 배치로 고아 데이터 정리 |
| 좋아요 COUNT 쿼리 비용 | 상품 조회 시 매번 likes COUNT 쿼리 발생 | 인덱스 활용. 성능 이슈 시 likeCount 캐싱 컬럼 도입 |
| 주문 시 재고 동시성 | 동시 주문 시 재고 차감의 정합성 문제 | 비관적 락 또는 낙관적 락으로 대응 (추후 동시성 처리 단계에서 해결) |
| 스냅샷 데이터 증가 | 주문마다 상품 정보를 복사하므로 데이터량 증가 | 주문 이력 조회 시 필요한 최소 정보만 스냅샷 |
| 대량 브랜드 삭제 | 상품이 많은 브랜드 삭제 시 soft delete 대상이 다수 | 배치 처리 또는 비동기 처리 고려 |

---

## 7. Checklist

- [x] 상품/브랜드/좋아요/주문 도메인이 모두 포함되어 있는가?
- [x] 기능 요구사항이 유저 중심으로 정리되어 있는가?
- [x] 추가 기능(장바구니)이 기존 요구사항과 일관되게 정의되어 있는가?
- [x] 각 유스케이스에 Main / Alternate / Exception Flow가 포함되어 있는가?
- [x] 유스케이스 흐름이 구체적인 번호 순서로 작성되어 있는가?
- [x] 예외/조건이 명시되어 있는가? (로그인 여부, 삭제 상태, 수량 제한 등)
- [x] 좋아요 수 반영 방식이 명시되어 있는가?
- [x] 상품 재고(stock) 관리 방식이 명시되어 있는가?
- [x] 설계 결정 근거가 명시되어 있는가?
- [x] 도메인 용어집(유비쿼터스 언어)이 정의되어 있는가?
