# 1. 목적 및 범위

### 프로젝트 목적
SSENSE와 같은 하이패션 이커머스 플랫폼을 설게한다.

고객이 브랜드별 상품을 탐색하고, 마음에 드는 상품에 좋아요를 표시하고, 여러 상품을 한 번에 주문할 수 있는 이커머스 서비스를 구축한다. 어드민은 브랜드와 상품을 관리하고, 주문 현황을 파악한다.


### 범위

본 문서가 다루는 범위는 다음 네 가지 도메인으로 **한정**한다.

- **브랜드** — 상품을 묶는 그룹 단위. 어드민이 관리하고, 고객이 조회한다.
- **상품** — 고객이 탐색하고 주문하는 대상. 등록시 브랜드가 반드시 존재해야한다.
- **좋아요** — 고객이 상품에 대한 관심을 표현하는 행위. 실제 구매를 하진 않지만 구매 후보를 표현하는 행위다.
- **장바구니** — 고객이 관심 있는 상품을 임시로 모아두는 공간. 주문 전 단계에서 상품을 선택·관리하고 주문으로 이어지기 쉽다.
- **주문** — 고객이 상품을 구매하는 행위. 주문 시점의 상품 정보가 보존된다.

### 액터

- **고객(User)** — 상품을 탐색하고, 좋아요를 누르고, 주문한다. 로그인이 필요한 행위와 필요 없는 행위가 구분된다.
- **어드민(Admin)** — 브랜드와 상품을 등록·수정·삭제하고, 전체 주문 현황을 조회한다.

### 범위 고정

- 유저(Users) 회원가입, 내 정보 조회, 비밀번호 변경 기능은 **이미 구현 완료**되어 본 문서에서 다루지 않는다.
- 인증/인가의 구체적 구현 방식은 기존 코드베이스의 패턴을 따르며, 본 문서에서는 **인증이 필요한지 여부만** 명시한다.
- 엔티티 필드는 **행동 기반으로 점진적으로 설계**한다. 각 시나리오가 요구하는 행동에 필요한 필드만 추가한다.

###  범위 제외 사항

| 제외 항목 | 사유 |
|---|---|
| 유저(Users) 기능 | 회원가입, 내 정보 조회, 비밀번호 변경은 이미 구현 완료 |
| 결제(Payment) | 향후 별도 단계에서 추가 개발 예정 |
| 쿠폰(Coupon) | 향후 별도 단계에서 추가 개발 예정 |
| 주문 상태 전이 | 결제 기능과 함께 추가. 현재는 주문 생성(ORDERED)만 다룬다 |
| 주문 취소 | 현재 범위에서 주문 취소 기능은 제공하지 않는다 |


# 2. 공통 정의

### 권한 정의
| 액터 | 설명 | 식별 방식 |
|------|------|----------|
| 비회원 (Guest) | 로그인하지 않은 사용자 | 헤더 없음 |
| 회원 (User) | 로그인한 사용자 | `X-Loopers-LoginId`, `X-Loopers-LoginPw` |
| 관리자 (Admin) | 사내 관리자 | `X-Loopers-Ldap: loopers.admin` |

### API Prefix 규칙
- 대고객 API: `/api/v1`
- 어드민 API: `/api-admin/v1`

### 도메인 용어집 (Ubiquitous Language)

| 한글 | 영문 | 설명 |
|------|------|------|
| 회원 | User | 서비스에 가입한 사용자. 1주차에 구현 완료 (본 설계 범위 제외) |
| 브랜드 | Brand | 상품을 판매하는 브랜드. Admin이 등록/관리 |
| 상품 | Product | 브랜드에 속한 판매 상품. 재고(stock) 포함 |
| 재고 | stock | 상품의 현재 판매 가능 수량. Product의 필드로 관리 |
| 품절 | Sold Out | 상품 재고(stock)가 0인 상태 |
| 좋아요 | Like | 회원이 상품에 대해 표현하는 선호. 회원당 상품당 1개. 별도 테이블로 관리 |
| 장바구니 | Cart | 회원이 구매 전 상품을 담아두는 보관함 |
| 장바구니 항목 | CartItem | 장바구니에 담긴 개별 상품과 수량 |
| 주문 | Order | 회원이 상품을 구매하기 위한 요청 |
| 주문 항목 | OrderItem | 주문에 포함된 개별 상품의 스냅샷 (주문 시점 가격/이름 등) |
| 스냅샷 | Snapshot | 주문 시점의 상품 정보를 복사하여 저장하는 것 |
| Soft Delete | - | deleted_at 컬럼으로 논리 삭제. 물리적으로는 데이터 유지 |
| Admin | Admin | LDAP 인증 기반 사내 관리자 |

### 도메인 참조 원칙

- **DB FK 제약 미사용** — 테이블 간 외래키 제약조건을 사용하지 않는다. 무결성은 애플리케이션 레벨에서 보장.
  - FK의 문제: 잠금 전파(데드락 위험), 삭제 순서 강제, 테이블 간 결합
- **DB 유니크 제약 사용** — 테이블 내부 제약은 사용한다 (FK와 성격이 다름). 동시성(더블클릭 등) 시 중복 방지.
- **참조 방식**
  - 같은 도메인 (Brand → Product): 객체참조 + FK 없음 (`@ManyToOne` + `ConstraintMode.NO_CONSTRAINT`)
  - 다른 도메인 간: ID 참조 (`private Long userId` 등)
- **Aggregate** — 각 도메인은 독립 Aggregate Root. `@OneToMany` 사용하지 않음. Aggregate 규칙은 Service에서 `@Transactional`로 관리.

---

# 3. 기능 요구 사항

## 3.1 브랜드 & 상품

> **비회원으로서**, 브랜드 정보를 조회하고 상품 목록을 둘러보고 상세 정보를 확인할 수 있다.
>
> **관리자로서**, 브랜드와 상품을 등록/수정/삭제하여 서비스에 입점할 브랜드와 판매 상품을 관리할 수 있다.

### 예외 및 정책

- **삭제 전략: Soft Delete** — `deleted_at` 컬럼으로 논리 삭제. 복구 가능성을 열어두고, 연관 데이터(장바구니/좋아요)는 조회 시 필터링으로 처리하여 트랜잭션 범위를 줄인다.
- **브랜드 삭제 연쇄 처리** — 브랜드 soft delete 시 해당 브랜드의 상품도 전체 soft delete. 장바구니/좋아요는 즉시 삭제하지 않고 조회 시점에 필터링.
  ```
  브랜드 soft delete
    └→ 해당 브랜드의 상품 전체 soft delete
        └→ 장바구니 항목: 조회 시 필터링
        └→ 좋아요: 조회 시 필터링
  ```
- **브랜드명 중복 불가** — 동일한 브랜드명이 이미 존재하면 등록/수정 실패 (409 Conflict)
- **상품 재고: Product 필드로 관리** — 별도 Stock 도메인 분리 없이 Product 엔티티의 stock 필드로 관리. 등록/수정 시 재고 설정, 주문 시 차감.
- **고객 vs Admin 응답 차이** — 고객에게는 기본 정보만, Admin에게는 등록일/수정일/삭제 여부 등 관리 정보 추가 제공
- **soft delete된 브랜드/상품** — 고객 조회 불가 (404 반환)
- **Brand → Product 참조** — 객체참조 + FK 없음. 코드에서 `product.getBrand().getName()` 접근 가능하되, DB에 FK 제약조건은 생성하지 않음.
- **각각 독립 Aggregate Root** — Brand와 Product는 별도 Aggregate Root. 브랜드 삭제 → 상품 soft delete는 Facade에서 조율.
- **Product.likeCount 캐시 필드** — 찜 수 조회 성능을 위해 Product에 likeCount 캐싱. 찜/취소 시 원자적 증감.

### API

**브랜드**

| 기능 | 액터 | Method | URI | 인증 |
|------|------|--------|-----|------|
| 브랜드 정보 조회 | 비회원/회원 | GET | `/api/v1/brands/{brandId}` | X |
| 브랜드 목록 조회 | Admin | GET | `/api-admin/v1/brands?page=0&size=20` | LDAP |
| 브랜드 상세 조회 | Admin | GET | `/api-admin/v1/brands/{brandId}` | LDAP |
| 브랜드 등록 | Admin | POST | `/api-admin/v1/brands` | LDAP |
| 브랜드 정보 수정 | Admin | PUT | `/api-admin/v1/brands/{brandId}` | LDAP |
| 브랜드 삭제 | Admin | DELETE | `/api-admin/v1/brands/{brandId}` | LDAP |

**상품**

| 기능 | 액터 | Method | URI | 인증 |
|------|------|--------|-----|------|
| 상품 목록 조회 | 비회원/회원 | GET | `/api/v1/products` | X |
| 상품 정보 조회 | 비회원/회원 | GET | `/api/v1/products/{productId}` | X |
| 상품 목록 조회 | Admin | GET | `/api-admin/v1/products?page=0&size=20&brandId={brandId}` | LDAP |
| 상품 상세 조회 | Admin | GET | `/api-admin/v1/products/{productId}` | LDAP |
| 상품 등록 | Admin | POST | `/api-admin/v1/products` | LDAP |
| 상품 정보 수정 | Admin | PUT | `/api-admin/v1/products/{productId}` | LDAP |
| 상품 삭제 | Admin | DELETE | `/api-admin/v1/products/{productId}` | LDAP |

**상품 목록 조회 쿼리 파라미터**

| 파라미터 | 설명 | 기본값 |
|----------|------|--------|
| `brandId` | 특정 브랜드 상품 필터링 | - (선택) |
| `sort` | 정렬 기준: `latest` / `price_asc` / `likes_desc` | `latest` |
| `page` | 페이지 번호 | 0 |
| `size` | 페이지당 상품 수 | 20 |

> `sort`는 `latest` 필수, `price_asc` / `likes_desc`는 선택 구현.
> `likes_desc` 정렬 시 좋아요 수는 Product.likeCount 필드로 정렬.

### 유즈케이스

**UC-B01: 브랜드 정보 조회 (비회원)**

```
[기능 흐름]
1. 비회원이 brandId로 브랜드 정보를 요청한다
2. 해당 브랜드가 존재하는지 확인한다
3. 브랜드 기본 정보를 반환한다

[예외]
- brandId에 해당하는 브랜드가 없으면 404 반환
- soft delete된 브랜드는 조회 불가 (404 반환)
```

**UC-B02: 브랜드 등록 (Admin)**

```
[기능 흐름]
1. Admin이 브랜드 정보(이름 등)를 입력한다
2. 동일한 브랜드명이 이미 존재하는지 확인한다
3. 브랜드를 저장한다
4. 생성된 브랜드 정보를 반환한다

[예외]
- 이미 존재하는 브랜드명이면 등록 실패 (409 Conflict)

[조건]
- 브랜드명은 필수값이며 중복 불가
```

**UC-B03: 브랜드 정보 수정 (Admin)**

```
[기능 흐름]
1. Admin이 brandId와 수정할 정보를 요청한다
2. 해당 브랜드가 존재하는지 확인한다
3. 브랜드 정보를 업데이트한다

[예외]
- brandId에 해당하는 브랜드가 없거나 삭제된 경우 404 반환
- 수정하려는 브랜드명이 다른 브랜드와 중복되면 409 Conflict
```

**UC-B04: 브랜드 삭제 (Admin)**

```
[기능 흐름]
1. Admin이 brandId로 삭제를 요청한다
2. 해당 브랜드가 존재하는지 확인한다
3. 해당 브랜드를 soft delete 한다
4. 해당 브랜드의 모든 상품도 soft delete 한다

[예외]
- brandId에 해당하는 브랜드가 없으면 404 반환
- 이미 삭제된 브랜드이면 404 반환
```

**UC-P01: 상품 목록 조회 (비회원)**

```
[기능 흐름]
1. 비회원이 상품 목록을 요청한다 (선택: brandId, sort, page, size)
2. soft delete된 상품/브랜드를 제외한다
3. 정렬 조건에 맞게 정렬한다
4. 페이지네이션하여 상품 목록을 반환한다
5. 각 상품의 좋아요 수를 Product.likeCount로 함께 반환한다

[대안 흐름]
- brandId가 없으면 전체 상품 조회
- sort가 없으면 latest(최신순) 기본 적용
```

**UC-P02: 상품 정보 조회 (비회원)**

```
[기능 흐름]
1. 비회원이 productId로 상품 정보를 요청한다
2. 해당 상품이 존재하는지 확인한다
3. 상품 정보와 함께 좋아요 수(Product.likeCount)를 반환한다

[예외]
- productId에 해당하는 상품이 없거나 삭제된 경우 404 반환
```

**UC-P03: 상품 등록 (Admin)**

```
[기능 흐름]
1. Admin이 상품 정보를 입력한다 (brandId, 상품명, 가격, 재고 등)
2. brandId에 해당하는 브랜드가 존재하는지 확인한다
3. 상품을 저장한다
4. 생성된 상품 정보를 반환한다

[예외]
- brandId에 해당하는 브랜드가 없거나 삭제된 경우 등록 실패

[조건]
- 상품의 브랜드는 반드시 이미 등록된(삭제되지 않은) 브랜드여야 함
- 재고(stock)는 상품 등록 시 초기값 설정 (0 이상)
```

**UC-P04: 상품 정보 수정 (Admin)**

```
[기능 흐름]
1. Admin이 productId와 수정할 정보를 요청한다
2. 해당 상품이 존재하는지 확인한다
3. 상품 정보를 업데이트한다

[예외]
- productId에 해당하는 상품이 없거나 삭제된 경우 404 반환

[조건]
- 상품의 브랜드(brandId)는 수정할 수 없음
- 재고(stock) 수정 가능
```

**UC-P05: 상품 삭제 (Admin)**

```
[기능 흐름]
1. Admin이 productId로 삭제를 요청한다
2. 해당 상품이 존재하는지 확인한다
3. 해당 상품을 soft delete 한다

[예외]
- productId에 해당하는 상품이 없거나 이미 삭제된 경우 404 반환
```

---

## 3.2 좋아요

> **회원으로서**, 마음에 드는 상품에 좋아요를 눌러 선호를 표현하고, 나중에 다시 찾아볼 수 있다.
> 이미 좋아요한 상품은 취소할 수 있다.

### 예외 및 정책

- **좋아요 수: Product.likeCount 캐시** — Like 엔티티가 원본 데이터, Product.likeCount는 조회 성능을 위한 파생값(derived data). 찜/취소 시 원자적 증감. 모든 상품 조회 API에서 서브쿼리 없이 사용.
- **API 방식: 엔드포인트 분리 + 내부 토글** — POST/DELETE 엔드포인트는 미션 스펙대로 분리하되, 내부적으로 같은 Facade 메서드(toggleLike)를 호출. 409/404 없음.
- **회원당 상품당 1개** — userId + productId DB 유니크 제약. 동시성(더블클릭) 시에도 중복 방지.
- **삭제된 상품/브랜드의 좋아요** — 목록 조회 시 필터링으로 제외.
- **상품 검증 항상 수행** — 등록/취소 모두 ProductService로 상품 존재 + 삭제 여부 확인. 삭제된 상품에 대한 좋아요 조작 방지.
- **참조 방식** — 모두 ID 참조 (userId, productId).
- **User 탈퇴 시** — Like 삭제 + Product.likeCount 감소.
- **Product 삭제 시** — Like 삭제.

### API

| 기능 | 액터 | Method | URI | 인증 |
|------|------|--------|-----|------|
| 상품 좋아요 등록 | 회원 | POST | `/api/v1/products/{productId}/likes` | O |
| 상품 좋아요 취소 | 회원 | DELETE | `/api/v1/products/{productId}/likes` | O |
| 내가 좋아요한 상품 목록 조회 | 회원 | GET | `/api/v1/users/{userId}/likes` | O |

### 유즈케이스

**UC-L01: 상품 좋아요 토글 (등록/취소)**

```
[기능 흐름]
1. 회원이 productId로 좋아요를 요청한다 (POST 또는 DELETE)
2. 해당 상품이 존재하는지 확인한다 (삭제된 상품 불가)
3. 좋아요 존재 여부를 확인한다
4-a. 좋아요가 없으면: 좋아요를 저장한다 (등록)
4-b. 좋아요가 있으면: 좋아요를 삭제한다 (취소)

[예외]
- productId에 해당하는 상품이 없거나 삭제된 경우 404 반환

[조건]
- 로그인한 회원만 가능
- 회원당 상품당 1개만 저장 (유니크 제약)
- POST/DELETE 모두 같은 Facade 메서드(toggleLike)를 호출
- 이미 좋아요한 상품에 POST → 좋아요 취소 (409 없음)
- 좋아요하지 않은 상품에 DELETE → 좋아요 등록 (404 없음)
```

**UC-L02: 내가 좋아요한 상품 목록 조회**

```
[기능 흐름]
1. 회원이 자신의 좋아요 목록을 요청한다
2. likes 테이블에서 해당 회원의 좋아요 목록을 조회한다
3. 상품/브랜드가 삭제되지 않은 항목만 필터링한다
4. 상품 정보와 함께 반환한다

[조건]
- 로그인한 회원만 가능
- soft delete된 상품/브랜드는 목록에서 제외 (조회 시 필터링)
- 본인의 좋아요 목록만 조회 가능 (타 유저 접근 불가)
```

---

## 3.3 주문

> **회원으로서**, 여러 상품을 한 번에 주문할 수 있다.
> 주문 시 상품 재고가 확인되고 차감된다.
> 주문 후에도 당시 상품 정보(가격, 이름 등)를 확인할 수 있다.
>
> **관리자로서**, 전체 주문 내역을 조회할 수 있다.

### 예외 및 정책

- **재고 확인 + 차감 원자적 처리** — 재고 확인과 차감은 하나의 트랜잭션 안에서 원자적으로 수행. 일괄 처리 방식(IN 쿼리).
- **스냅샷 저장** — 주문 시점의 상품 정보(상품명, 가격, 브랜드명)를 OrderItem에 복사. 이후 상품이 변경/삭제되어도 주문 내역은 보존.
- **재고 부족 시 주문 전체 실패** — 하나의 상품이라도 재고 부족이면 주문 전체가 롤백. 부분 성공 없음.
- **items 비어있으면 실패** — 주문 항목이 없는 요청은 거부.
- **동시성 이슈** — 추후 비관적 락 또는 낙관적 락으로 해결 예정.
- **가격 변동 검증** — 주문 시점에 클라이언트가 보낸 expectedPrice와 Product의 현재 가격을 비교. 불일치 시 주문 실패 ("가격이 변경되었습니다"). 하이패션 고가 상품의 가격 분쟁 방지.
- **두 가지 주문 경로** — 바로구매(상품 페이지에서 직접)와 장바구니 주문. Order 도메인은 출처를 모르고, Facade가 경로를 조율. 주문 로직은 단일.
- **스냅샷 구조** — OrderItem에 @Embedded ProductSnapshot (productName, brandName, imageUrl 등). productId는 별도 유지 (재구매, 통계용, FK 아님).
- **Order ↔ OrderItem** — ID 참조 (orderId). @OneToMany 미사용. 같은 Aggregate이지만 프로젝트 전체 ID 참조 패턴과 일관성 유지.
- **User 탈퇴 시** — 주문 데이터 DB 유지 (비즈니스 기록). UserSnapshot 불필요 (탈퇴한 유저는 조회 주체가 사라짐).

### API

| 기능 | 액터 | Method | URI | 인증 |
|------|------|--------|-----|------|
| 주문 요청 | 회원 | POST | `/api/v1/orders` | O |
| 주문 목록 조회 | 회원 | GET | `/api/v1/orders?startAt={date}&endAt={date}` | O |
| 주문 상세 조회 | 회원 | GET | `/api/v1/orders/{orderId}` | O |
| 주문 목록 조회 | Admin | GET | `/api-admin/v1/orders?page=0&size=20` | LDAP |
| 주문 상세 조회 | Admin | GET | `/api-admin/v1/orders/{orderId}` | LDAP |

**주문 요청 본문 예시**

```json
{
  "items": [
    { "productId": 1, "quantity": 2, "expectedPrice": 50000 },
    { "productId": 3, "quantity": 1, "expectedPrice": 120000 }
  ]
}
```

### 유즈케이스

**UC-O01: 주문 요청**

```
[기능 흐름]
1. 회원이 상품 목록(productId, quantity, expectedPrice)으로 주문을 요청한다
2. 각 상품이 존재하는지 확인한다 (삭제된 상품 불가)
3. 각 상품의 expectedPrice와 현재 가격을 비교한다 (불일치 시 실패)
4. 각 상품의 재고가 충분한지 확인한다
5. 재고를 차감한다 (원자적 처리)
6. 주문 시점의 상품 정보를 스냅샷으로 저장한다 (ProductSnapshot: 상품명, 브랜드명, 이미지 등)
7. 주문을 생성한다

[예외]
- 상품이 존재하지 않거나 삭제된 경우 주문 실패
- expectedPrice와 현재 가격이 불일치하면 주문 실패
- 재고가 부족한 상품이 하나라도 있으면 주문 전체 실패
- items가 비어있으면 주문 실패

[조건]
- 로그인한 회원만 가능
- 바로구매/장바구니 주문 모두 같은 API 사용 (Order 도메인은 출처를 모름)
- 재고 확인과 차감은 원자적으로 처리되어야 함
- 동시성 이슈는 추후 해결 (비관적 락 또는 낙관적 락)
```

**UC-O02: 주문 목록 조회 (회원)**

```
[기능 흐름]
1. 회원이 기간(startAt, endAt)을 지정하여 주문 목록을 요청한다
2. 해당 기간 내 본인의 주문 목록을 반환한다

[조건]
- 본인의 주문만 조회 가능
- startAt, endAt은 필수값 (기간 지정 필수)
```

**UC-O03: 주문 상세 조회 (회원)**

```
[기능 흐름]
1. 회원이 orderId로 주문 상세를 요청한다
2. 해당 주문이 존재하는지 확인한다
3. 본인의 주문인지 확인한다
4. 주문 정보와 스냅샷된 상품 정보를 반환한다

[예외]
- orderId에 해당하는 주문이 없으면 404 반환
- 본인의 주문이 아니면 접근 불가

[조건]
- 본인의 주문만 조회 가능
- 상품 정보는 스냅샷 기준 (현재 상품 상태와 무관)
```

---

## 3.4 장바구니

> **회원으로서**, 구매하고 싶은 상품을 장바구니에 담아두고 나중에 한 번에 확인할 수 있다.
> 담은 상품의 수량을 변경하거나 제거할 수 있다.
> 장바구니에 품절 상품이 있으면 품절 상태로, 삭제된 상품은 판매 종료 상태로 보여준다.

### 예외 및 정책

- **Cart 엔티티 미사용** — DB에 Cart 테이블 없음. CartItem만 DB 엔티티. Cart는 코드에서 일급 컬렉션(First-Class Collection)으로 표현하여 "전체 가격 계산", "선택 항목 추출" 등 장바구니 단위 행위를 응집.
- **가격: 현재 가격 기준** — CartItem에 가격을 저장하지 않음 (가격의 원천은 항상 Product). 조회 시 항상 현재 상품 가격 사용. 하이패션 시즌 세일 시 장바구니에 담아둔 상품의 세일 가격이 자동 반영.
- **재고: 담기 시 미확인** — 장바구니에 담을 때 재고는 확인하지 않음. 주문 시점에만 확인. 장바구니는 "보관함" 성격.
- **주문과 독립** — Cart 도메인과 Order 도메인은 서로를 모른다. Facade가 경로를 조율.
  ```
  [장바구니 → 주문 흐름]
  장바구니 → CartItem 조회 → OrderItemCommand 변환 → OrderService 호출 → CartItem 삭제

  [바로구매 흐름]
  상품 페이지 → OrderItemCommand 직접 생성 → OrderService 호출
  ```
- **품절 상품** — 장바구니에서 자동 제거하지 않음. 품절 표시하고 유저가 직접 제거. 하이패션에서 신중하게 골라 담은 상품이 자동으로 사라지면 UX 저하.
- **삭제된 상품(SoftDelete)** — 판매 종료 표시 + 주문 불가. SoftDelete이므로 상품 데이터가 남아있어 표시 가능.
- **CartItem 유니크 제약** — userId + productId DB 유니크 제약. 동시성(더블클릭) 시에도 중복 CartItem 방지.
- **참조 방식** — ID 참조 (userId, productId). 스냅샷 불필요 (항상 Product에서 현재 정보 조회).
- **User 탈퇴 시** — CartItem 삭제.
- **제약 조건**

  | 제약 | 값 | 근거 |
  |------|-----|------|
  | 상품당 최대 수량 | 99개 | 비정상 요청 방어 |
  | 장바구니 최대 종류 | 100종 | 합리적 상한 + 페이지네이션 적용 |
  | 최소 수량 | 1개 | 수량 0은 불가. 제거는 DELETE API로 명확히 분리 |
  | quantity | 필수값 | 기본값 없음. 클라이언트가 명시적으로 전달 |

### API

| 기능 | 액터 | Method | URI | 인증 |
|------|------|--------|-----|------|
| 장바구니에 상품 담기 | 회원 | POST | `/api/v1/carts` | O |
| 장바구니 목록 조회 | 회원 | GET | `/api/v1/carts?page=0&size=20` | O |
| 장바구니 수량 변경 | 회원 | PUT | `/api/v1/carts/{cartItemId}` | O |
| 장바구니 항목 제거 | 회원 | DELETE | `/api/v1/carts/{cartItemId}` | O |

### 유즈케이스

**UC-C01: 장바구니에 상품 담기**

```
[기능 흐름]
1. 회원이 productId와 quantity(필수)로 담기를 요청한다
2. 해당 상품이 존재하는지 확인한다 (삭제된 상품 불가)
3. 장바구니에 같은 상품이 이미 있는지 확인한다
4-a. 없으면: 새 CartItem을 저장한다
4-b. 있으면: 기존 수량에 요청 수량을 합산한다

[예외]
- productId에 해당하는 상품이 없거나 삭제된 경우 실패
- 합산 후 수량이 99를 초과하면 실패
- 장바구니에 이미 100종류가 담겨있으면 신규 상품 담기 실패

[조건]
- quantity는 필수값 (기본값 없음), 1 이상
- 담을 때 재고는 확인하지 않음 (주문 시점에 확인)
- 가격은 저장하지 않음 (조회 시 현재 가격 사용)
- 로그인한 회원만 가능
```

**UC-C02: 장바구니 목록 조회**

```
[기능 흐름]
1. 회원이 장바구니 목록을 요청한다 (page, size)
2. 해당 회원의 장바구니 항목을 조회한다
3. 각 항목의 상품/브랜드 상태를 확인한다
4. 품절(stock=0) 상품은 품절 상태를 표시한다
5. 삭제된(SoftDelete) 상품은 판매 종료 상태를 표시한다
6. 상품의 현재 정보(이름, 가격, 재고 상태)와 함께 반환한다

[조건]
- 가격은 항상 현재 상품 가격 기준 (CartItem에 가격 저장 안 함, 가격의 원천은 Product)
- 페이지네이션 적용 (장바구니 최대 100종류)
- 본인의 장바구니만 조회 가능
- 로그인한 회원만 가능
```

**UC-C03: 장바구니 수량 변경**

```
[기능 흐름]
1. 회원이 cartItemId와 변경할 quantity를 요청한다
2. 해당 장바구니 항목이 존재하는지 확인한다
3. 본인의 장바구니 항목인지 확인한다
4. 수량을 업데이트한다

[예외]
- cartItemId에 해당하는 항목이 없으면 404 반환
- 수량이 1 미만이면 실패 (최소 1)
- 수량이 99 초과이면 실패 (최대 99)

[조건]
- 수량 0으로 변경 불가 → 제거는 DELETE API로만 가능
- 본인의 장바구니 항목만 수정 가능
- 로그인한 회원만 가능
```

**UC-C04: 장바구니 항목 제거**

```
[기능 흐름]
1. 회원이 cartItemId로 제거를 요청한다
2. 해당 장바구니 항목이 존재하는지 확인한다
3. 본인의 장바구니 항목인지 확인한다
4. 해당 항목을 삭제한다

[예외]
- cartItemId에 해당하는 항목이 없으면 404 반환

[조건]
- 본인의 장바구니 항목만 제거 가능
- 로그인한 회원만 가능
```
